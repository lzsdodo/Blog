<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dodo&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.zsliang.me/"/>
  <updated>2019-04-20T00:37:53.000Z</updated>
  <id>https://blog.zsliang.me/</id>
  
  <author>
    <name>Zachary</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Upcoming</title>
    <link href="https://blog.zsliang.me/posts/ffffffff/"/>
    <id>https://blog.zsliang.me/posts/ffffffff/</id>
    <published>2100-01-01T04:59:59.000Z</published>
    <updated>2019-04-20T00:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Still transferring previous articles from other platforms. </p></blockquote><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/ffffffff/">https://blog.zsliang.me/posts/ffffffff/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Still transferring previous articles from other platforms. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br \=&quot;&quot;&gt;&lt;strong&gt;Author:&amp;nbsp;Zachary&lt;/stro
      
    
    </summary>
    
      <category term="nil" scheme="https://blog.zsliang.me/categories/nil/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>[object Object]</title>
    <link href="https://blog.zsliang.me/posts/824ac3d0/"/>
    <id>https://blog.zsliang.me/posts/824ac3d0/</id>
    <published>2019-08-05T05:57:23.000Z</published>
    <updated>2019-08-18T09:15:44.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Title</p></blockquote><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/824ac3d0/">https://blog.zsliang.me/posts/824ac3d0/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Title&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br \=&quot;&quot;&gt;&lt;strong&gt;Author:&amp;nbsp;Zachary&lt;/strong&gt;&lt;br \=&quot;&quot;&gt;&lt;strong&gt;Post link:&amp;nbsp;&lt;/strong&gt; &lt;a href=
      
    
    </summary>
    
      <category term="Cook" scheme="https://blog.zsliang.me/categories/Cook/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>[object Object]</title>
    <link href="https://blog.zsliang.me/posts/824ac3d0/"/>
    <id>https://blog.zsliang.me/posts/824ac3d0/</id>
    <published>2019-08-05T05:57:23.000Z</published>
    <updated>2019-08-18T09:15:44.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 干锅菜花 </p></blockquote><ul><li><p> 材料 </p><ul><li> 菜花 </li><li> 五花肉 </li><li> 辣椒 </li><li> 姜 </li><li> 蒜 </li><li> 酱油 1 勺 （或生抽 + 老抽）</li></ul></li><li><p> 做法 </p><ul><li> 菜花冲洗干净，小刀沿着柄削成小朵，淡盐水浸泡 10 分钟，然后冲洗干净后充分晾干水分 </li><li> 五花肉切片 </li><li> 酱油一勺，辣椒切圈，生姜切片，大蒜拍散切小块 </li><li> 五花肉入锅，加姜片小火慢炒出油 </li><li> 肉推开一边，切大火，倒入菜花，略停 30 秒再翻炒几下 </li><li> 盖上锅盖，中火焗 30 秒，菜花头有点焦色 </li><li> 加入辣椒和大蒜碎炒匀，然后再加入一勺酱油，继续翻炒均匀 </li><li> 起锅前加入一勺盐炒匀 </li></ul></li><li><p>Memo</p><ul><li> 酱油可以用生抽加老抽代替，老抽数滴即可，多了毁颜色 </li><li> 盐最后加入，炒匀后分布在菜花的表面，入口咸香 </li></ul></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/824ac3d0/">https://blog.zsliang.me/posts/824ac3d0/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 干锅菜花 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt; 材料 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 菜花 &lt;/li&gt;
&lt;li&gt; 五花肉 &lt;/li&gt;
&lt;li&gt; 辣椒 &lt;/li&gt;
&lt;li&gt; 姜 &lt;/li&gt;
&lt;li&gt; 蒜 &lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Cook" scheme="https://blog.zsliang.me/categories/Cook/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>[object Object]</title>
    <link href="https://blog.zsliang.me/posts/824ac3d0/"/>
    <id>https://blog.zsliang.me/posts/824ac3d0/</id>
    <published>2019-08-05T05:57:23.000Z</published>
    <updated>2019-08-18T09:15:44.101Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 芋圆 </p></blockquote><blockquote><p> 做芋圆，对糊化程度的要求没那么高，只要有糊化，就能成功做出来 </p></blockquote><ul><li><p> 芋圆红豆汤 / 芋圆仙草冻 </p></li><li><p> 芋圆 / 紫薯圆 </p><ul><li> 香芋 / 紫薯 / 红薯 100g</li><li> 木薯淀粉 Tapioca starch 55g (菱粉 Three Ladies Brand)</li><li> 沸水 35g</li><li> 细砂糖（防粘）20g</li></ul></li><li> 烧仙草 <ul><li> 仙草粉 50g</li><li> 食用水 </li></ul></li><li> 配料 <ul><li> 炼奶 Condensed milk</li><li> 纯牛奶 Milk</li><li> 蜜红豆 Honey red bean 120g</li></ul></li></ul><blockquote><p> 此配方每 100 克芋头 / 紫薯 / 红薯，可以制作 200 克左右的芋圆 </p></blockquote><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/824ac3d0/">https://blog.zsliang.me/posts/824ac3d0/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 芋圆 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 做芋圆，对糊化程度的要求没那么高，只要有糊化，就能成功做出来 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt; 芋圆红豆汤 / 芋圆仙草冻 &lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="Cook" scheme="https://blog.zsliang.me/categories/Cook/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>[object Object]</title>
    <link href="https://blog.zsliang.me/posts/824ac3d0/"/>
    <id>https://blog.zsliang.me/posts/824ac3d0/</id>
    <published>2019-08-05T05:57:23.000Z</published>
    <updated>2019-08-18T09:15:44.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 法式吐司 </p></blockquote><blockquote><p>《电影食堂》-《克莱默夫妇》</p></blockquote><ul><li><p> 材料 2 人份 </p><ul><li>4 片吐司（6 片装厚型吐司）</li><li>2 个鸡蛋 </li><li>1 杯牛奶 </li><li>1 大勺砂糖 </li><li> 适量黄油 </li><li> 适量蜂蜜 </li></ul></li><li><p> 做法 </p><ol><li> 深盆敲入鸡蛋打成蛋液，加入牛奶、砂糖混合均匀，把吐司浸入。</li><li> 平底煎锅热黄油，待融化后放入吐司，盖上锅盖。</li><li> 待煎到有焦色时翻面，再盖上锅盖，使两面都煎到。</li><li> 最后，依据喜好淋上蜂蜜或枫糖即可。</li></ol></li><li><p>Memo</p><ul><li> 煎到表面略焦、中间柔软是最理想的状况。</li><li> 小火盖着锅盖，使吐司整体受热均匀，能够达到柔软蓬松的效果。</li></ul></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/824ac3d0/">https://blog.zsliang.me/posts/824ac3d0/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 法式吐司 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;《电影食堂》-《克莱默夫妇》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt; 材料 2 人份 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4 片吐司（6 片装厚型吐司）
      
    
    </summary>
    
      <category term="Cook" scheme="https://blog.zsliang.me/categories/Cook/"/>
    
    
      <category term="Breakfast" scheme="https://blog.zsliang.me/tags/Breakfast/"/>
    
  </entry>
  
  <entry>
    <title>[object Object]</title>
    <link href="https://blog.zsliang.me/posts/824ac3d0/"/>
    <id>https://blog.zsliang.me/posts/824ac3d0/</id>
    <published>2019-08-05T05:57:23.000Z</published>
    <updated>2019-08-18T09:15:44.101Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 蒜蓉白灼菜心 </p></blockquote><ul><li><p> 材料 </p><ul><li> 菜心 500g</li><li> 姜丝 2 片 </li><li> 蒜 3 瓣 </li><li> 花生油 </li><li> 生抽 </li><li> 蚝油 </li><li> 鱼露 </li></ul></li><li><p> 做法 </p><ul><li> 摘去老叶，清水洗净，泡 10 分钟左右，此时将姜片切丝，剁碎蒜蓉 </li><li> 锅加入清水，加入少许油和盐，等烧开 </li><li> 烧开后倒入菜心，筷子翻动下，根据大小调整时间，一般 1-2 分钟，喜欢脆口感可以时间稍短。</li><li> 捞出摆盘 </li><li> 另起锅放入食用油，加入姜丝蒜茸爆香，加入一点盐、生抽和蚝油调味，再将热油淋在菜心里。</li></ul></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/824ac3d0/">https://blog.zsliang.me/posts/824ac3d0/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 蒜蓉白灼菜心 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt; 材料 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 菜心 500g&lt;/li&gt;
&lt;li&gt; 姜丝 2 片 &lt;/li&gt;
&lt;li&gt; 蒜 3 瓣 &lt;/li&gt;
&lt;li&gt; 花生油 &lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="Cook" scheme="https://blog.zsliang.me/categories/Cook/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>[object Object]</title>
    <link href="https://blog.zsliang.me/posts/824ac3d0/"/>
    <id>https://blog.zsliang.me/posts/824ac3d0/</id>
    <published>2019-08-05T05:57:23.000Z</published>
    <updated>2019-08-18T09:15:44.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 土豆炖牛肉 </p></blockquote><ul><li><p> 材料 </p><ul><li>🐂beef 牛肉 1kg</li><li>🥔potato 土豆 2 个 </li><li>🍅tomato 番茄 2 个 </li><li> 洋葱 2 个 </li><li>🥕 carrot 胡萝卜 1 个 </li><li> 姜葱 适量 </li><li> 老抽、料酒 一大勺 </li><li> 醋、糖 一小勺 </li><li> 番茄沙司 适量 </li><li> 黑胡椒 适量 </li><li> 油、盐 </li></ul></li><li><p> 做法 </p><ol><li> 牛肉切块冷水下锅焯 2 分钟，全程用温水清洗干净。</li><li> 配料洗净切块，（土豆块泡清水里）待用。</li><li> 锅放油烧热，先下牛肉煸炒一下，烹人老抽，料酒和一小勺白醋。</li><li> 接着下洋葱西红柿，撒一勺白糖继续翻炒。</li><li> 挤人番茄沙司（多挤一些），再磨一些胡椒粒炒匀。</li><li> 放葱姜，倒入足够的热水，中大火烧 20 分钟改小火炖 1 小时左右。</li><li> 出锅前放土豆胡萝卜块加盐烧熟。</li><li> 等到肉烂，汤汁粘稠就可以调味出锅了。</li></ol></li><li><p>Memo</p><ul><li> 牛肉要选牛腩肋条这一部分，肥瘦相间吃起来很嫩不柴。焯水之后要用温水清洗，如果用冷水一激牛肉就不容易炖烂了。</li></ul></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/824ac3d0/">https://blog.zsliang.me/posts/824ac3d0/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 土豆炖牛肉 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt; 材料 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;🐂beef 牛肉 1kg&lt;/li&gt;
&lt;li&gt;🥔potato 土豆 2 个 &lt;/li&gt;
&lt;li&gt;🍅tomato 番茄 2 个 &lt;/l
      
    
    </summary>
    
      <category term="Cook" scheme="https://blog.zsliang.me/categories/Cook/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>Concurrency</title>
    <link href="https://blog.zsliang.me/posts/9c149c9f/"/>
    <id>https://blog.zsliang.me/posts/9c149c9f/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-08-18T09:15:44.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Concurrency</p></blockquote><p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#problem">Problem</a><ul><li><a href="#i-o">I/O</a></li><li><a href="#process-thread-coroutine">Process, Thread &amp; Coroutine</a></li></ul></li><li><a href="#concurrent-model">Concurrent Model</a><ul><li><a href="#thread-lock">Thread &amp; Lock</a></li><li><a href="#actor-model">Actor Model</a></li><li><a href="#csp-model">CSP Model</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- tocstop --></div><hr><blockquote><p>Concurrency is not Parallelism. - <a href="https://talks.golang.org/2012/concurrency.slide#1" rel="external nofollow noopener noreferrer" target="_blank">Go Concurrency Patterns, Google IO 2012</a></p></blockquote><h2><span id="problem">Problem</span><a href="#problem" class="header-anchor">#</a></h2><blockquote><p><a href="http://www.kegel.com/c10k.html#top" rel="external nofollow noopener noreferrer" target="_blank">The C10K problem</a>: Handling 10,000 clients simultaneously through a single server.</p></blockquote><blockquote><p>CPU operation is more faster than I/O operation, so <strong>I/O strategies</strong> is important in the same hardware condition.</p></blockquote><h3><span id="i-o">I/O</span><a href="#i-o" class="header-anchor">#</a></h3><h3><span id="process-thread-amp-coroutine">Process, Thread &amp; Coroutine</span><a href="#process-thread-amp-coroutine" class="header-anchor">#</a></h3><hr><h2><span id="concurrent-model">Concurrent Model</span><a href="#concurrent-model" class="header-anchor">#</a></h2><h3><span id="thread-amp-lock">Thread &amp; Lock</span><a href="#thread-amp-lock" class="header-anchor">#</a></h3><h3><span id="actor-model">Actor Model</span><a href="#actor-model" class="header-anchor">#</a></h3><blockquote><p>One ant is no ant, one actor is no actor.</p></blockquote><ul><li>Actor is the basic unit, and actors do not share memory.</li><li>Message is the only communication approach.</li><li><p>Actor is like a mailbox handler, handling different type of mail.</p></li><li><p>Actor’s feature</p><ul><li>Each actor has a mailbox</li><li>Actor handle the mail sequentially</li><li>The message in actor is unmutable</li></ul></li><li><p>Actor hase to implement 3 basic part</p><ul><li>Processing</li><li>Storage<ul><li>Mailbox (messageQueue)</li></ul></li><li>Communication</li></ul></li><li><p>The Actor Model</p><ul><li>Everything is an actor</li><li>An actor has a mailbox, which is also an actor and needs a mailbox</li><li>Axioms<ol><li>Create more actors</li><li>Send messages to actors that it has addresses before</li><li>Designate what to do with the next message</li></ol></li><li>Conceptually 1 message at a time.</li><li>Message can <strong>be dilivered at most one time</strong> in <strong>arbitrary order</strong></li><li>Address != Identity<ul><li>Many-to-many relationship among actors and addresses</li></ul></li><li>No channel, they go directly</li></ul></li><li><p>Akka</p><ul><li>The underlying layer is still using the synchronization mechanism of Java and JVM</li><li>It does not use any lock mechanism which means it will not appear deadlock</li><li>The processing of concurrent execution does not use thread switching (improve thread efficiency and reduce the cost of switching thread)</li><li>Provides a higher level of concurrent abstract models</li></ul></li></ul><h3><span id="csp-model">CSP Model</span><a href="#csp-model" class="header-anchor">#</a></h3><blockquote><p>CSP: Golang (<a href="https://golang.org/src/runtime/chan.go" rel="external nofollow noopener noreferrer" target="_blank">src/runtime/chan.go</a> which is also ref to <a href="https://swtch.com/libtask/" rel="external nofollow noopener noreferrer" target="_blank">Libtask: a Coroutine Library for C and Unix</a>)</p></blockquote><hr><h2><span id="reference">Reference</span><a href="#reference" class="header-anchor">#</a></h2><ul><li><a href="https://en.wikipedia.org/wiki/Concurrency_control" rel="external nofollow noopener noreferrer" target="_blank">Wiki - Concurrency</a></li><li><a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29" rel="external nofollow noopener noreferrer" target="_blank">Lock</a></li><li><a href="https://en.wikipedia.org/wiki/Actor_model" rel="external nofollow noopener noreferrer" target="_blank">Wiki Actor Model</a></li><li><a href="https://www.youtube.com/watch?v=7erJ1DV_Tlo" rel="external nofollow noopener noreferrer" target="_blank">Youtube: The Actor Model</a></li><li><a href="https://akka.io/" rel="external nofollow noopener noreferrer" target="_blank">Java/Scala - Akka</a></li><li><a href="https://github.com/godpan/akka-demo" rel="external nofollow noopener noreferrer" target="_blank">Akka series demo</a></li><li><a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" rel="external nofollow noopener noreferrer" target="_blank">Wiki CSP</a></li><li><a href="https://zhuanlan.zhihu.com/p/44917920" rel="external nofollow noopener noreferrer" target="_blank"> 并发模型之间的比较 知乎 </a></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/9c149c9f/">https://blog.zsliang.me/posts/9c149c9f/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Concurrency&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#problem&quot;&gt;Problem&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="CS" scheme="https://blog.zsliang.me/categories/CS/"/>
    
    
      <category term="Concurrency" scheme="https://blog.zsliang.me/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Socket</title>
    <link href="https://blog.zsliang.me/posts/2496d8d/"/>
    <id>https://blog.zsliang.me/posts/2496d8d/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-08-18T09:15:44.103Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><!-- tocstop --></div><hr><blockquote><p>What is a socket?<br>To the kernel, a socket is an endpoint of communication<br>To an application, a socket is a file descriptor that lets the application read/write from/to the network</p><blockquote><p>All Unix I/O devices, including networks, are modeled as files.</p></blockquote></blockquote><ul><li><p>Two types of socket</p><ul><li>Based on file system<ul><li><code>_fd file descriptor</code></li></ul></li><li>Based on network<ul><li><code>protocol, IP, port</code></li></ul></li></ul></li><li><p>Usually <code>C/S</code> model</p><ul><li>Client<ul><li><code>New Socket()</code>, <code>Connect()</code>, <code>Recv()/Send()</code>, <code>Close()</code></li><li>Status: <code>established</code>, <code>syn_send</code></li></ul></li><li>Server<ul><li><code>New Socket()</code>, <code>Bind()</code>, <code>Listen()</code>, <code>Accept()</code>, <code>Recv()/Send()</code>, <code>Close()</code></li><li>Status: <code>established</code>, <code>syn_rcvd</code></li></ul></li><li>3 time shake<ul><li>Connecting: C: <code>SYN</code>; S: <code>SYN+ACK</code>; C: <code>ACK</code>;</li><li>Closing: C: <code>FIN</code>; S: <code>ACK</code>; S: <code>FIN</code>; C: <code>ACK</code>;</li></ul></li></ul></li><li><p>Each socket maintaining 2 queue</p><ul><li>A queue of connected client which is at the </li></ul></li><li><p>Communication between 2 process</p><ul><li>We need to find out the other process<ul><li>In local ENV, we we use PID because it’s unique in local ENV.</li><li>In network, we know IP is unique for an host, and TCP protocol can find out the unique process for this host with its port.<blockquote><p><code>IP:PORT</code> (Contains 2 protocol: TCP/IP)</p></blockquote></li></ul></li></ul></li></ul><p><img src="https://pic2.zhimg.com/v2-c397b75852db5484b834239709eca8d7_r.jpg" alt=""></p><ul><li> 内核中，Socket 是一个文件，那对应就有文件描述符。</li><li> 每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。</li><li> 文件描述符是一个整数，是这个数组的下标。</li><li> 数组中的内容是一个指针，指向内核中所有打开的文件的列表。</li><li> 既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode 不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。<ul><li>Diff from <code>fd</code></li></ul></li><li> 在这个 inode 中，指向了 Socket 在内核中的 Socket 结构。</li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/2496d8d/">https://blog.zsliang.me/posts/2496d8d/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;!-- tocstop --&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;What is a socket?&lt;br&gt;To the kernel, a socket is a
      
    
    </summary>
    
      <category term="CS" scheme="https://blog.zsliang.me/categories/CS/"/>
    
    
      <category term="Socket" scheme="https://blog.zsliang.me/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>HashTable</title>
    <link href="https://blog.zsliang.me/posts/57ef054a/"/>
    <id>https://blog.zsliang.me/posts/57ef054a/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-08-18T09:15:44.102Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#set-map-and-hashtable">Set/Map and HashTable</a></li><li><a href="#hash-function">Hash Function</a></li><li><a href="#example">Example</a></li></ul><!-- tocstop --></div><hr><h2><span id="set-map-and-hashtable">Set/Map and HashTable</span><a href="#set-map-and-hashtable" class="header-anchor">#</a></h2><ul><li>Hash Table<ul><li>Key -&gt; Hash Function -&gt; Table -&gt; Value</li><li> 系统是否可以提供若干个较小的连续空间，而每个空间又能存放一定数量的记录 </li></ul></li></ul><h2><span id="hash-function">Hash Function</span><a href="#hash-function" class="header-anchor">#</a></h2><blockquote><p>Like classifing different categories</p></blockquote><ul><li><p>Hash Function Requirement</p><ul><li>Hash function should return an unsigned integer.</li><li>if <code>key1 == key2</code>, then <code>hash(key1) == hash(key2)</code></li><li>if <code>key1 != key2</code>, then <code>hash(key1) != hash(key2)</code></li></ul></li><li><p>MOD </p><ul><li>Coherence Theorem (同余定理) is like Classification</li><li> 将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出 </li><li><code>f(x) = x mod size</code><ul><li>Optim - improve the randomness by adding salt: <code>f(x) = (x + salt) mod size</code></li></ul></li></ul></li><li><p>Collision</p><ul><li>Table -&gt; Linked List -&gt; Value</li></ul></li></ul><h2><span id="example">Example</span><a href="#example" class="header-anchor">#</a></h2><ul><li>In Java <ul><li>default size=16</li><li>default 0.75 * capacity -&gt; expension</li></ul></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/57ef054a/">https://blog.zsliang.me/posts/57ef054a/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#set-map-and-hashtable&quot;&gt;Set/Map and HashTable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#hash-fun
      
    
    </summary>
    
      <category term="nil" scheme="https://blog.zsliang.me/categories/nil/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree</title>
    <link href="https://blog.zsliang.me/posts/dcc99588/"/>
    <id>https://blog.zsliang.me/posts/dcc99588/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-05-12T02:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#operation">Operation</a></li><li><a href="#support-duplication">Support duplication</a></li><li><a href="#runtime">Runtime</a></li><li><a href="#why-bst-not-hashtable">Why BST not HashTable</a></li><li><a href="#bst-variants">BST Variants</a><ul><li><a href="#red-black-tree">Red-black tree</a></li><li><a href="#b-tree">B+ Tree</a></li></ul></li></ul><!-- tocstop --></div><hr><blockquote><p>Binary Search Tree<br>A data structure created for quick search.</p></blockquote><ul><li><p>Definition</p></li><li><p>BST (Ordered Binary Tree)</p><ol><li>All nodes’ value on current nodes’ left subtree are smaller than current node’s value</li><li>All nodes’ value on current nodes’ right subtree are greater than current node’s value</li><li>Recursively, both left subtree and right subtree are BST</li></ol></li><li><p>Main features</p><ul><li>Support insert, delete and lookup operation in <code>O(logn)</code> time.</li></ul></li></ul><h2><span id="operation">Operation</span><a href="#operation" class="header-anchor">#</a></h2><ul><li><p>Node</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Find operation</p><ul><li><p>T: <code>O(logn)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(root, target.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(Node root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; node.data) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; node.data) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Find father node</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findFather</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findFather(root, target.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findFather</span><span class="params">(Node root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node node   = root;</span><br><span class="line">    Node father = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.val == data) </span><br><span class="line">            <span class="keyword">return</span> father;</span><br><span class="line"></span><br><span class="line">        father = node;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; node.val) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt;= node.val</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Not exist</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Insert operation</p><ul><li>Usually we insert new data on a leaf node.</li><li>If new data is bigger than node’s data.<ol><li>The node has no right child, insert to its right child’s position. </li><li>Recursively find the position in the node’s right subtree.</li></ol></li><li><p>If new data is smaller than node’s data, similar to the instructions above.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; node.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt;= node.data</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.left == <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Delete operation</p><ul><li>3 situations under consideration<ol><li>The node to be deleted is a leaf node.<ul><li>Set it as null from its father node.</li></ul></li><li>The node has a child.<ul><li>Replace the node with its child.</li></ul></li><li>The node has two child.<ul><li>Find the min node in its right tree and replace the node with that min node.</li><li>Delete that min node from its original position.</li></ul></li></ol></li></ul></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node node   = root; </span><br><span class="line">    Node father = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find position</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.data != data) &#123;</span><br><span class="line">        father = node;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; node.data) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt;= node.data</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// Not exist</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Two child</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node minNode = node.right;</span><br><span class="line">        Node minNodeFather = node;</span><br><span class="line">        <span class="keyword">while</span> (minNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minNodeFather = minNode;</span><br><span class="line">            minNode = minNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node.data = minNode.data;   <span class="comment">// Replace node's data</span></span><br><span class="line">        node   = minNode;           <span class="comment">// Delete minNode</span></span><br><span class="line">        father = minNodeFather;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// One child or no child</span></span><br><span class="line">    Node child = <span class="keyword">null</span>; <span class="comment">// Node's child</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = node.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = node.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (father == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = child; <span class="comment">// Delete root</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (father.left == node) &#123;</span><br><span class="line">        father.left = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// father.right == node</span></span><br><span class="line">        father.right = child;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>Find max/min node</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMin</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node node = root;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMax</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node node = root;</span><br><span class="line">    <span class="keyword">while</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Find predecessor/successor node</p><ul><li><p>Predecessor</p><ol><li><p>Find max node of left subtree</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  o(node)</span><br><span class="line"> / \</span><br><span class="line">o   o</span><br><span class="line"> \</span><br><span class="line">  o(pred)</span><br></pre></td></tr></table></figure></li><li><p>Find father node (the node is father’s right child)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> o(pred)</span><br><span class="line">  \</span><br><span class="line">   o(node)</span><br><span class="line">  / \</span><br><span class="line">null o</span><br></pre></td></tr></table></figure></li><li><p>Find left side father node</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     o(pred)</span><br><span class="line">      \</span><br><span class="line">       o</span><br><span class="line">      /</span><br><span class="line">     o</span><br><span class="line">    /</span><br><span class="line">   o(node)</span><br><span class="line">  / \</span><br><span class="line">null o</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findPredecessor</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Node node = find(root, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) <span class="keyword">return</span> findMax(node.left);</span><br><span class="line"></span><br><span class="line">    TreeNode father = findFather(root, node);</span><br><span class="line">    <span class="keyword">while</span> (father != <span class="keyword">null</span> &amp;&amp; node == father.left) &#123;</span><br><span class="line">        node = father;</span><br><span class="line">        father = findFather(root, node);</span><br><span class="line">        <span class="comment">// it would be more easier if there is pointer for father node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// father == null =&gt; not exist or root</span></span><br><span class="line">    <span class="comment">// node   == father.right =&gt; father node is the predecessor</span></span><br><span class="line">    <span class="keyword">return</span> father;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Successor</p><ol><li><p>Find min node of right subtree</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  o(node)</span><br><span class="line"> / \</span><br><span class="line">o   o</span><br><span class="line">   /</span><br><span class="line">  o(succ)</span><br></pre></td></tr></table></figure></li><li><p>Find father node (the node is father’s left child)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    o(succ)</span><br><span class="line">   /</span><br><span class="line">  o(node)</span><br><span class="line"> / \</span><br><span class="line">o   null</span><br></pre></td></tr></table></figure></li><li><p>Find right side father node</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  o(pred)</span><br><span class="line"> /</span><br><span class="line">o</span><br><span class="line"> \</span><br><span class="line">  o</span><br><span class="line">   \</span><br><span class="line">    o(node)</span><br><span class="line">   / \</span><br><span class="line">  o  null</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findSuccessor</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Node node = find(root, target);</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) <span class="keyword">return</span> findMin(node);</span><br><span class="line"></span><br><span class="line">    TreeNode father = findFather(node);</span><br><span class="line">    <span class="keyword">while</span> (father != <span class="keyword">null</span> &amp;&amp; node == father.right) &#123;</span><br><span class="line">        node = father;</span><br><span class="line">        father = findFather(root, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2><span id="support-duplication">Support duplication</span><a href="#support-duplication" class="header-anchor">#</a></h2><ul><li><p>In practice, the data stored in BST usually is a multi-field object</p><ul><li>We take one field as the key to build the BST.</li><li>Other fields are called satellite data.</li></ul></li><li><p>What if there are two key that has same value</p><ol><li>Use datastructure like linked list and array (support dynamic expansion) to store those objects on the same node.</li><li>Inset that object to its right tree. (consider it with a greater key value)<ul><li>For <code>find()</code>, we <strong>keep looking up on candidate node’s right subtree until we meet a leaf node</strong> so that we find out all the nodes with same key value.</li><li>For <code>delete()</code>, we also need to find out all the nodes with the same key value and delete it one by one.</li></ul></li></ol></li></ul><h2><span id="runtime">Runtime</span><a href="#runtime" class="header-anchor">#</a></h2><ul><li>Time: <code>O(logn)</code></li><li><p>Worst: <code>O(n)</code></p><ul><li>BST deterioratded to an unbalanced binary tree (extreme case a linked list)</li></ul></li><li><p>Nodes (assume max layer is <code>L</code>)</p><ul><li><code>n &gt;= 1 + 2 + 4 + 8 + ... + 2^(L-2) + 1</code></li><li><code>n &lt;= 1 + 2 + 4 + 8 + ... + 2^(L-2) + 2^(L-1)</code></li></ul></li><li><p>Level</p><ul><li><code>[log2(n+1), log2n + 1]</code></li></ul></li></ul><hr><h2><span id="why-bst-not-hashtable">Why BST not HashTable</span><a href="#why-bst-not-hashtable" class="header-anchor">#</a></h2><ul><li><p>HashTable have insert/delete/find operation in <code>O(1)</code> time</p><ul><li>But it is not stored in order, we can get an sorted list by inorder traversing the BST in <code>O(n)</code> time</li><li>Capacity expansion is time-consuming for HashTable</li><li>HashTable’s performance is not stable because of hash collision</li><li>Designing hash function, solving hash collision, capacity expansion and etc. to be considered, while BST just need to solve the balancing problem and it has a mature scheme like red-black tree.</li></ul></li><li><p>Choosing the data structure according to the application scene</p></li></ul><hr><h2><span id="bst-variants">BST Variants</span><a href="#bst-variants" class="header-anchor">#</a></h2><h3><span id="red-black-tree">Red-black tree</span><a href="#red-black-tree" class="header-anchor">#</a></h3><blockquote><p>Balanced BST</p></blockquote><h3><span id="b-tree">B+ Tree</span><a href="#b-tree" class="header-anchor">#</a></h3><blockquote><p>Support outputing in range</p></blockquote><hr><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/dcc99588/">https://blog.zsliang.me/posts/dcc99588/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#operation&quot;&gt;Operation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#support-duplication&quot;&gt;Support dup
      
    
    </summary>
    
      <category term="Data Structure" scheme="https://blog.zsliang.me/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="https://blog.zsliang.me/tags/Data-Structure/"/>
    
      <category term="Tree" scheme="https://blog.zsliang.me/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Sorting Algorithm</title>
    <link href="https://blog.zsliang.me/posts/b59a5e11/"/>
    <id>https://blog.zsliang.me/posts/b59a5e11/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-04-20T17:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#analysis">Analysis</a></li><li><a href="#sorting-algorithm">Sorting Algorithm</a><ul><li><a href="#bubble-sort-mou-pao-pai-xu">Bubble Sort 冒泡排序 </a></li><li><a href="#insertion-sort-cha-ru-pai-xu">Insertion Sort 插入排序 </a></li><li><a href="#selection-sort">Selection Sort</a></li><li><a href="#merge-sort-gui-bing-pai-xu">Merge Sort 归并排序 </a></li><li><a href="#quick-sort-kuai-su-pai-xu">Quick Sort 快速排序 </a></li><li><a href="#bucket-sort">Bucket Sort</a></li><li><a href="#counting-sort">Counting Sort</a></li><li><a href="#radix-sort">Radix Sort</a></li><li><a href="#timsort">Timsort</a></li><li><a href="#heap-sort">Heap sort</a></li></ul></li><li><a href="#optimization">Optimization</a></li><li><a href="#other-case">Other case</a></li><li><a href="#reference">Reference</a></li></ul><!-- tocstop --></div><hr><blockquote><p>Sorting Algorithm</p></blockquote><table><thead><tr><th style="text-align:center">Sorting Algo</th><th style="text-align:center">In-place</th><th style="text-align:center">Stability</th><th style="text-align:center">Time Complexity (AVG/BEST/WORST)</th><th style="text-align:center">Space Complexity</th></tr></thead><tbody><tr><td style="text-align:center">Bubble Sort</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">O(n^2) / O(n) / O(n^2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Insertion Sort</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">O(n^2) / O(n) / O(n^2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Selection Sort</td><td style="text-align:center">✓</td><td style="text-align:center">x</td><td style="text-align:center">O(n^2) / O(n^2) / O(n^2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Merge Sort</td><td style="text-align:center">x</td><td style="text-align:center">✓</td><td style="text-align:center">O(nlogn) / O(nlogn) / O(nlogn)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">Quick Sort</td><td style="text-align:center">✓</td><td style="text-align:center">x</td><td style="text-align:center">O(nlogn) / O(nlogn) / O(n^2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Bucket Sort</td><td style="text-align:center">x</td><td style="text-align:center">✓</td><td style="text-align:center">O(n + k) / O(n + k) / O(n^2)</td><td style="text-align:center">O(n + k)</td></tr><tr><td style="text-align:center">Counting Sort</td><td style="text-align:center">x</td><td style="text-align:center">✓</td><td style="text-align:center">O(n + k) / O(n + k) / O(n + k)</td><td style="text-align:center">O(k)</td></tr><tr><td style="text-align:center">Radix Sort</td><td style="text-align:center">x</td><td style="text-align:center">✓</td><td style="text-align:center">O(nd) / O(nd) / O(nd)</td><td style="text-align:center">O(n + d)</td></tr><tr><td style="text-align:center">Heap Sort</td><td style="text-align:center">✓</td><td style="text-align:center">x</td><td style="text-align:center">O(nlogn) / O(nlogn) / O(nlogn)</td><td style="text-align:center">O(1)</td></tr></tbody></table><h2><span id="analysis">Analysis</span><a href="#analysis" class="header-anchor">#</a></h2><ol><li><p>Performace 执行效率 </p><ul><li>Time Complexity<ul><li>Avg, Best case, Worst case</li></ul></li><li>Compare &amp; Swap opreation<ul><li> 交换次数等于逆序度 </li></ul></li><li>Scale</li></ul></li><li><p>Space Complexity 内存消耗 </p><blockquote><p>Sorted in place</p></blockquote></li><li><p>Stability 稳定性 </p><blockquote><p> 值相等的元素，经过排序后，相等元素之间原有的先后顺序不变。</p></blockquote></li><li><p> 有序度 &amp; 逆序度 </p><blockquote><p> 有序度是数组中具有有序关系的元素对的个数。<br>Oredered: n*(n-1)/2 (满有序度)<br> 逆序度 = 满有序度 - 有序度 </p></blockquote></li></ol><hr><h2><span id="sorting-algorithm">Sorting Algorithm</span><a href="#sorting-algorithm" class="header-anchor">#</a></h2><ul><li><p><strong> 基于比较排序的算法下界 </strong> <code>O(nlogn)</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Q: 已知有数组 [a1, a2, ..., an]，求数组特定的一个排序组合 </span><br><span class="line">A: </span><br><span class="line">    组合数：n!</span><br><span class="line">    断言：ai &gt; aj，可排除一半的情况 =&gt; n!/2</span><br><span class="line">    若比较 k 次能得到该特定的排序，求 k。</span><br><span class="line">    =&gt; n! / 2^k = 1</span><br><span class="line">    =&gt; 2^k = n!</span><br><span class="line">    =&gt; k = log(n!) &amp;&amp; log(n!) &lt; log(n^n)</span><br><span class="line">    =&gt; k ≈ nlog(n)</span><br></pre></td></tr></table></figure></li></ul><h3><span id="bubble-sort-mou-pao-pai-xu">Bubble Sort 冒泡排序 </span><a href="#bubble-sort-mou-pao-pai-xu" class="header-anchor">#</a></h3><ul><li>Features<ol><li>In place sort</li><li>Stability</li><li>Best: <code>O(n)</code>, Worst: <code>O(n^2)</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> swapped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>; <span class="comment">// No swap</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="insertion-sort-cha-ru-pai-xu">Insertion Sort 插入排序 </span><a href="#insertion-sort-cha-ru-pai-xu" class="header-anchor">#</a></h3><ul><li>Feature<ol><li>In place sort</li><li>Stability</li><li>Best: O(n), Worst: O(n^2)</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Find seout where to insert</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; arr[j]) &#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[j+<span class="number">1</span>] = val; <span class="comment">// Insert</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="selection-sort">Selection Sort</span><a href="#selection-sort" class="header-anchor">#</a></h3><ul><li>Feature<ol><li>In place sort</li><li>Non-Stability</li><li>Best: O(n), Worst: O(n^2)</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = arr[i];</span><br><span class="line">        <span class="keyword">int</span> minIdx = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                minIdxinser = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Swap</span></span><br><span class="line">        arr[minIdx] = arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="merge-sort-gui-bing-pai-xu">Merge Sort 归并排序 </span><a href="#merge-sort-gui-bing-pai-xu" class="header-anchor">#</a></h3><blockquote><p>Divide and Conquer<br>BOTTOM TO TOP</p></blockquote><ul><li>Features<ol><li>Not in place sort =&gt; space: O(n)</li><li>Not-Stability</li><li>Time-Avg: O(nlogn)</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// DaC</span></span><br><span class="line">        mergeSort(arr, low, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">// Merge</span></span><br><span class="line">        mergeArr(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeArr</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] sortedArr = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, idx1 = low, idx2 = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (idx1 &lt;= mid &amp;&amp; idx2 &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[idx1] &lt; arr[idx2]) &#123;</span><br><span class="line">            sortedArr[k++] = arr[idx1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sortedArr[k++] = arr[idx2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (idx1 &lt;= mid) &#123;</span><br><span class="line">        sortedArr[k++] = arr[idx1++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (idx2 &lt;= high) &#123;</span><br><span class="line">        sortedArr[k++] = arr[idx2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low, j=<span class="number">0</span>; i&lt;=high; i++, j++) &#123;</span><br><span class="line">        arr[i] = sortedArr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="quick-sort-kuai-su-pai-xu">Quick Sort 快速排序 </span><a href="#quick-sort-kuai-su-pai-xu" class="header-anchor">#</a></h3><blockquote><p>Divide and Conquer<br>TOP to BOTTOM</p></blockquote><ul><li><p>Features</p><ol><li>In place sort =&gt; space: O(1)</li><li>Not-Stability</li><li>Time-Avg: O(nlogn), <ul><li>Worst: O(n^2) depending on the <code>pivot</code> value</li></ul></li></ol></li><li><p>How to optimzie <strong>quick sort</strong></p><ul><li>Choose a better <strong>pivot</strong> which can even split the array<ul><li>Pick the median of <code>arr[low], arr[(low+high)/2], arr[high]</code> as pivot</li><li>Randomly pick an element as pivot</li><li>Many other methods</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. In place sort, Space: O(1)</span></span><br><span class="line">    <span class="comment">// 2. Not-Stability</span></span><br><span class="line">    <span class="comment">// 3. Time-Avg: O(nlogn), Worst: O(n^2)</span></span><br><span class="line">    <span class="comment">// TOP to BOTTOM</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> divIdx = partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, divIdx - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, divIdx + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot  = arr[high]; <span class="comment">// Find pivot</span></span><br><span class="line">    <span class="keyword">int</span> divIdx = low;       <span class="comment">// Divide index</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            swap(arr, divIdx++, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, divIdx, high);</span><br><span class="line">    <span class="keyword">return</span> divIdx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPivot</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nMid = arr[low + ((high - low) &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;arr[low], nMid, arr[high]&#125;; </span><br><span class="line">    <span class="comment">// 3 point median</span></span><br><span class="line">    <span class="keyword">if</span> (num[<span class="number">0</span>] &gt; num[<span class="number">1</span>]) swap(num, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (num[<span class="number">1</span>] &gt; num[<span class="number">2</span>]) swap(num, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (num[<span class="number">0</span>] &gt; num[<span class="number">1</span>]) swap(num, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="bucket-sort">Bucket Sort</span><a href="#bucket-sort" class="header-anchor">#</a></h3><ul><li><p>Analysis</p><ul><li>Assume there are m buckets, each bucket has $k = n / m$ elements</li><li>Use quick sort in each bucket in O(klogk) time</li><li>Total in $O(m * klogk) = O(nlogk)$ time</li><li>When $m ≈ n$, which means k is really small =&gt; $O(nlogk) ≈ O(n)$</li></ul></li><li><p>Suitable for big data, when we can not load all the data in RAM at the same time (外部排序)</p></li><li><p>Case</p><ul><li>Question<ul><li> 有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</li></ul></li><li>Answer<ol><li> 先扫描一遍文件，看订单金额所处的数据范围。</li><li> 将所有订单根据金额划分到 100 个桶。</li><li> 理想的情况下，如果订单金额均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100 MB。</li><li> 将这 100 个小文件依次放到内存中，用快排来排序。</li><li> 所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中。</li></ol></li></ul></li></ul><h3><span id="counting-sort">Counting Sort</span><a href="#counting-sort" class="header-anchor">#</a></h3><ul><li>Analysis<ul><li>It’s like a special case of bucket sort.</li><li> 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。</li><li> 而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Data range: [0, 9]</span><br><span class="line">Input data: [1, 4, 1, 2, 7, 5, 2]</span><br><span class="line"></span><br><span class="line">1) Take a count array to store the count of each unique object.</span><br><span class="line">Index: 0  1  2  3  4  5  6  7  8  9</span><br><span class="line">Count: 0  2  2  0  1  1  0  1  0  0</span><br><span class="line"></span><br><span class="line">2) Add prefix sum</span><br><span class="line">Index: 0  1  2  3  4  5  6  7  8  9</span><br><span class="line">Count: 0  2  4  4  5  6  6  7  7  7</span><br><span class="line"></span><br><span class="line">3) Output each object from the input sequence followed by </span><br><span class="line">  decreasing its count by 1.</span><br><span class="line">Process the input data: [1, 4, 1, 2, 7, 5, 2].</span><br><span class="line">Index: 0  1  2  3  4  5  6  7  8  9</span><br><span class="line">Count: 0  2  4  4  5  6  6  7  7  7</span><br><span class="line">// [-&gt;1, 4, 1, 2, 7, 5, 2]</span><br><span class="line">Count: 0  2-1 4  4  5  6  6  7  7  7</span><br><span class="line">Index: 0  1   2  3  4  5  6</span><br><span class="line">Data:  -  *1  -  -  -  -  -</span><br><span class="line">// [1, -&gt;4, 1, 2, 7, 5, 2]</span><br><span class="line">Count: 0  1  4  4  5-1 6  6  7  7  7</span><br><span class="line">Index: 0  1  2  3  4   5  6</span><br><span class="line">Data:  -  1  -  -  *4  -  -</span><br><span class="line">// [1, 4, -&gt;1, 2, 7, 5, 2]</span><br><span class="line">Index: 0  1   2  3  4  5  6</span><br><span class="line">Count: 0  1-1 4  4  4  6  6  7  7  7    </span><br><span class="line">Data:  *1 1   -  -  4  -  -</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围 </span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 遍历数组的所有的元素，找到最大的元素 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">     <span class="comment">// 若后面的元素大于指定的数组元素，则把元素进行交换 </span></span><br><span class="line">     <span class="keyword">if</span> (max &lt; a[i]) max = a[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个计数数组 c，下标大小 [0,max]</span></span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 c 中 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组 r，存储排序之后的结果 </span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给 a 数组 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="radix-sort">Radix Sort</span><a href="#radix-sort" class="header-anchor">#</a></h3><ul><li><p><img src="http://7xqccv.com1.z0.glb.clouddn.com//18-6-21/95335203.jpg" alt="Radix Sort"></p></li><li><p>Analysis</p><ul><li> 基数排序对要排序的数据是有要求的，需要可以分割出独立的 “位” 来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。</li><li> 除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O (n) 了。</li></ul></li><li><p>Case</p><ul><li>Question<ul><li> 如何根据年龄给 100 万用户排序？(Like sorting 1 million phone number)</li></ul></li><li>Answer<ul><li>Make it all the username or uid the same length<ul><li>(ban, candy, john, …) =&gt; (ban00, candy, john0) </li><li>‘0’ &lt; any letter in ASCII value</li></ul></li><li>Radix sort (Assume the size of username or uid is smaller than 20)<ul><li>Time complexity is similar to O(n)</li></ul></li></ul></li></ul></li></ul><h3><span id="timsort">Timsort</span><a href="#timsort" class="header-anchor">#</a></h3><blockquote><p>Timsort is a <strong>hybrid stable sorting algorithm</strong>, derived from <strong>merge sort</strong> and <strong>insertion sort</strong>, designed to perform well on many kinds of real-world data.</p></blockquote><ul><li>Using neat merge method<ol><li> 找出左分区最后一个元素 (最大) 及在右分区的位置 </li><li> 找出右分区第一个元素 (最小) 及在左分区的位置 </li><li> 仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的 </li></ol></li></ul><h3><span id="heap-sort">Heap sort</span><a href="#heap-sort" class="header-anchor">#</a></h3><blockquote><p>See data structure “heap”</p></blockquote><hr><h2><span id="optimization">Optimization</span><a href="#optimization" class="header-anchor">#</a></h2><ul><li><p>Choose the sorting algo according to the data size</p><ul><li>When the element is less than <strong>5</strong>, it will sorted by <strong>insertion sort</strong><ul><li>When O(nlogn) is actually calculated as $f(n) = knlogn + c$, it may bigger than $f(n) = n ^ 2$</li><li>Like $n = 100$, $k = 1000$, $c = 200$</li><li>So for a small size of data, algorithm with <code>O(n^2)</code> maybe a better choice</li></ul></li><li>When the capacity is small, like <strong>1k, 2k</strong>, … we can choose <strong>merge sort</strong></li></ul></li><li><p>Case</p><ul><li>Java 1.8<ul><li>[0, 47]: <strong>Selection sort</strong></li><li>[47, 286]: <strong>Quick sort</strong> (Dual Pivot Quick Sort)</li><li>[286, …]: <strong>Timsort</strong> (merge sort)</li><li>For some basic type like <code>byte, char, short</code>: <strong>Counting sort</strong></li></ul></li><li>Google v8 quick sort<ul><li>[10, 1000]: choose <code>arr[mid]</code> as pivot</li><li>[1000, …]: Pick an elements from every 200 elements and choose the median as pivot.</li><li>Split in 3 part: <code>[&lt;pivot], [=pivot], [&gt;pivot]</code></li></ul></li><li>Glibc qsort()<ul><li>[0, 4]: <strong>Insertion sort</strong></li><li>Small size: <strong>Merge sort</strong></li><li>Large size: <strong>Quick sort</strong></li><li>Implement a stack on heap in case of stack overflow</li></ul></li></ul></li></ul><hr><h2><span id="other-case">Other case</span><a href="#other-case" class="header-anchor">#</a></h2><ul><li>Case 1<ul><li>Question<ul><li> 现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能 “快速” 地将这 10 个日志文件合并吗？</li></ul></li><li>Answer<ul><li> 维持一个按时间戳排序的 Min Heap。</li><li> 依次读取日志文件并放入 Min Heap 中。</li><li> 同时从 Min Heap 取出最早的日志存到合并文件中。</li></ul></li></ul></li></ul><hr><h2><span id="reference">Reference</span><a href="#reference" class="header-anchor">#</a></h2><ul><li><a href="https://time.geekbang.org/column/intro/126" rel="external nofollow noopener noreferrer" target="_blank"> 数据结构与算法之美 11-14</a></li><li><a href="https://mp.weixin.qq.com/s/pgPfAYbD-itnCeMTSXHueQ" rel="external nofollow noopener noreferrer" target="_blank"> 排序算法 </a></li><li><a href="https://www.youtube.com/watch?v=7zuGmKfUt7s&amp;feature=youtu.be" rel="external nofollow noopener noreferrer" target="_blank">Counting Sort | GeeksforGeeks - YouTube</a></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/b59a5e11/">https://blog.zsliang.me/posts/b59a5e11/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#analysis&quot;&gt;Analysis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sorting-algorithm&quot;&gt;Sorting Algorit
      
    
    </summary>
    
      <category term="Algo" scheme="https://blog.zsliang.me/categories/Algo/"/>
    
    
      <category term="Algo" scheme="https://blog.zsliang.me/tags/Algo/"/>
    
      <category term="Sorting" scheme="https://blog.zsliang.me/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Algorithm</title>
    <link href="https://blog.zsliang.me/posts/cf581b8c/"/>
    <id>https://blog.zsliang.me/posts/cf581b8c/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-08-18T09:11:40.737Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#complexity-analyse">Complexity Analyse</a></li><li><a href="#restriction">Restriction</a></li><li><a href="#implementation">Implementation</a></li><li><a href="#variants">Variants</a></li><li><a href="#skip-list-support-binary-search-for-linkedlist">Skip List - Support Binary Search for LinkedList</a></li><li><a href="#point-of-view">Point of view</a></li><li><a href="#case">Case</a></li><li><a href="#reference">Reference</a></li></ul><!-- tocstop --></div><hr><blockquote><p>Binary Search</p></blockquote><blockquote><p>Although the first binary search algorithm appeared in 1946, the first completely correct binary search algorithm was not implemented until 1962. - Donald E.Knuth</p></blockquote><hr><h2><span id="complexity-analyse">Complexity Analyse</span><a href="#complexity-analyse" class="header-anchor">#</a></h2><ul><li><p>Time</p><ul><li>Avg: <code>O(logn)</code></li><li>Worst: <code>O(logn)</code></li><li>Best: <code>O(1)</code></li></ul></li><li><p>Space</p><ul><li>Recursion: <code>O(logn)</code></li><li>Iteration: <code>O(1)</code></li></ul></li><li><p>Attention</p><ul><li>Stop condition </li><li>How to update lower &amp; upper bound (<code>low</code> &amp; <code>high</code>)</li><li>How to choose the return value (<code>mid</code>)</li></ul></li></ul><hr><h2><span id="restriction">Restriction</span><a href="#restriction" class="header-anchor">#</a></h2><ol><li>Sorted/Ordered 单调递增或递减 </li><li>Bounded 存在上下界 </li><li>Accessible by index 可通过索引访问 <ul><li>Fit for array not linked list</li></ul></li><li>Not suitable for dataset which is too small or too big <ul><li>Too small, the performance is similar</li><li>Too big, the data is not stored consequently</li></ul></li></ol><hr><h2><span id="implementation">Implementation</span><a href="#implementation" class="header-anchor">#</a></h2><ul><li><p>Iteration</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bsearch(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>, target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = start, right = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left  = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Recursion</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; target)</span><br><span class="line">        <span class="keyword">return</span> bsearch(arr, start, mid - <span class="number">1</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line">        <span class="keyword">return</span> bsearch(arr, mid + <span class="number">1</span>, end, data);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mid;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2><span id="variants">Variants</span><a href="#variants" class="header-anchor">#</a></h2><ol><li><p>Find the <strong>first target / last target</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstTarget</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = start, right = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left  = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// Equal, first of arr || first of repeated target</span></span><br><span class="line">            <span class="keyword">if</span> ((mid == start) || (nums[mid - <span class="number">1</span>] != target))</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// left = mid + 1;</span></span><br><span class="line">            <span class="comment">// Equal, last of arr || last of repeated target</span></span><br><span class="line">            <span class="comment">// if ((mid == end) || (nums[mid + 1] != target))</span></span><br><span class="line">            <span class="comment">//     return mid;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Find the <strong>first number <code>&gt;= target</code> / last number <code>&lt;= target</code></strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstBigger</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = start, right = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// &gt;=, first of arr || first elem bigger than target</span></span><br><span class="line">            <span class="keyword">if</span>((mid == start) || (nums[mid - <span class="number">1</span>] &lt; target))</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left  = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// last number smaller than target</span></span><br><span class="line">        <span class="comment">// if (nums[mid] &lt;= target) &#123;</span></span><br><span class="line">        <span class="comment">//     left  = mid + 1;</span></span><br><span class="line">        <span class="comment">//     // &gt;=, end of arr || last elem smaller than target</span></span><br><span class="line">        <span class="comment">//     if ((mid == end) || (nums[mid + 1] &gt; target))</span></span><br><span class="line">        <span class="comment">//         return mid;</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     right = mid - 1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>Attention<ul><li>Duplicates</li><li>Out of range: <code>target &lt; nums[0]</code> / <code>target &gt; nums[nums.length - 1]</code></li></ul></li></ul><h2><span id="skip-list-support-binary-search-for-linkedlist">Skip List - Support Binary Search for LinkedList</span><a href="#skip-list-support-binary-search-for-linkedlist" class="header-anchor">#</a></h2><blockquote><p>Reform linked list in order to support binary search, which is <strong>skip list</strong>. (跳表)<br>It’s a outstanding dynamic data structure. (Sometime Red-black tree can replaced by skip list)<br>Sorted Set in Redis is implemented with skip list and hashmap.</p></blockquote><ul><li><p>What is skip list</p><ul><li>Linked list with multi-level indice.</li></ul></li><li><p>How many indice do we need</p><ul><li>Given a linked list with size n.</li><li>Number of indice nodes at level <code>k</code> is <code>#: n / 2^k</code></li><li>Assume there <code>h</code> level, $h = log2n - 1$<ul><li>When <code>maxLevel = 1</code>, it’s just a simple linked list</li></ul></li></ul></li><li><p>Time complexity</p><ul><li>Assume we need to traverse m nodes at each index layer</li><li><code>O(mlogn)</code> and <code>max(m) = 3</code> =&gt; <code>O(logn)</code></li></ul></li><li><p>Space complexity</p><ul><li>Indice nodes number: $n/2 + n/4 + … + 4 + 2 = n - 2$</li><li><code>O(n)</code></li><li>In order to reduce the size, we can add a index node every 3 or 5 nodes rather than 2 nodes. ($n/3 + n/9 + … + 9 + 3 + 1 ≈ n/2 = O(n)$)</li><li>But considering the nodes are just pointers, we don’t need to store the object itself, so in many cases we can just ignore the this extra space.</li></ul></li><li><p>Operation</p><ul><li><code>Insert</code> / <code>Delete</code> / <code>Search</code> in <code>O(logn)</code></li><li>Maintain index<ul><li>When insert an new element, add a new index through a random function</li></ul></li><li><code>Search in range</code> (which is better than Red-black tree)</li><li><a href="https://github.com/wangzheng0822/algo/blob/master/java/17_skiplist/SkipList.java" rel="external nofollow noopener noreferrer" target="_blank">Ref Code</a></li></ul></li><li><p>Summary</p><ul><li> 跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O (logn)。</li><li> 跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</li><li> 跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的 “二分查找”。</li><li> 虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。</li></ul></li></ul><h2><span id="point-of-view">Point of view</span><a href="#point-of-view" class="header-anchor">#</a></h2><ul><li>A problem which can be solved by binary search, we usually prefer to solve by <strong>hash table</strong> or <strong>binary search tree</strong>. 凡是用二分查找能解决的，绝大部分我们更倾向于用 HashTable 或者 BST。</li><li>Binary search is more useful in searching <strong>vague</strong> value problem. 二分查找更适合用在 “近似” 查找问题。</li></ul><h2><span id="case">Case</span><a href="#case" class="header-anchor">#</a></h2><ul><li><p>Q1: 假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？</p><ul><li>Answer<ul><li> 最简单的办法就是将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。<ul><li> 先排序，再查找。</li></ul></li><li> 大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。<ul><li> 不管是散列表还是二叉树，都会需要比较多的额外的内存空间。</li><li> 如果用散列表或者二叉树来存储这 1000 万的数据，用 100MB 的内存肯定是存不下的。</li></ul></li></ul></li></ul></li><li><p>Q2: 假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</p><ul><li>Answer<ul><li> 如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。</li><li> 如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。</li><li> 所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</li><li> 要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间。</li><li> 然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</li></ul></li></ul></li></ul><h2><span id="reference">Reference</span><a href="#reference" class="header-anchor">#</a></h2><ul><li><a href="https://time.geekbang.org/column/intro/126" rel="external nofollow noopener noreferrer" target="_blank"> 数据结构与算法之美 15-17</a></li><li><a href="https://blog.csdn.net/tinkle181129/article/details/80037111" rel="external nofollow noopener noreferrer" target="_blank">Leetcode Binary Search 知识点总结 </a></li><li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" rel="external nofollow noopener noreferrer" target="_blank">LC-034 Find First and Last Position of Element in Sorted Array</a></li><li><a href="https://leetcode.com/problems/search-insert-position/" rel="external nofollow noopener noreferrer" target="_blank">LC-035 Search Insert Position</a></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/cf581b8c/">https://blog.zsliang.me/posts/cf581b8c/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#complexity-analyse&quot;&gt;Complexity Analyse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#restriction&quot;&gt;R
      
    
    </summary>
    
      <category term="Algo" scheme="https://blog.zsliang.me/categories/Algo/"/>
    
    
      <category term="Algo" scheme="https://blog.zsliang.me/tags/Algo/"/>
    
      <category term="Binary Search" scheme="https://blog.zsliang.me/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm in life</title>
    <link href="https://blog.zsliang.me/posts/ec40279f/"/>
    <id>https://blog.zsliang.me/posts/ec40279f/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-08-18T09:15:44.096Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#algorithm-in-life-sheng-huo-li-de-suan-fa">Algorithm in life 生活里的算法 </a><ul><li><a href="#37">37%</a></li><li><a href="#priority-queue">Priority Queue</a></li><li><a href="#kelly-formula-kai-li-gong-shi">Kelly Formula 凯利公式 </a></li><li><a href="#game-theory-bo-yi-lun">Game Theory 博弈论 </a></li></ul></li></ul><!-- tocstop --></div><hr><h1><span id="algorithm-in-life-sheng-huo-li-de-suan-fa">Algorithm in life 生活里的算法 </span><a href="#algorithm-in-life-sheng-huo-li-de-suan-fa" class="header-anchor">#</a></h1><h2><span id="37">37%</span><a href="#37" class="header-anchor">#</a></h2><ul><li> 适用范围 <ul><li> 找房子、买东西、换工作等 </li></ul></li></ul><h2><span id="priority-queue">Priority Queue</span><a href="#priority-queue" class="header-anchor">#</a></h2><ul><li> 一个任务的密度 = 重要程度 / 完成时间 </li></ul><h2><span id="kelly-formula-kai-li-gong-shi">Kelly Formula 凯利公式 </span><a href="#kelly-formula-kai-li-gong-shi" class="header-anchor">#</a></h2><h2><span id="game-theory-bo-yi-lun">Game Theory 博弈论 </span><a href="#game-theory-bo-yi-lun" class="header-anchor">#</a></h2><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/ec40279f/">https://blog.zsliang.me/posts/ec40279f/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#algorithm-in-life-sheng-huo-li-de-suan-fa&quot;&gt;Algorithm in life 生活里的算法 &lt;/a&gt;&lt;ul&gt;
      
    
    </summary>
    
      <category term="Algo" scheme="https://blog.zsliang.me/categories/Algo/"/>
    
    
      <category term="Algo" scheme="https://blog.zsliang.me/tags/Algo/"/>
    
  </entry>
  
  <entry>
    <title>TITLE</title>
    <link href="https://blog.zsliang.me/posts/dc62badb/"/>
    <id>https://blog.zsliang.me/posts/dc62badb/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-08-18T09:15:44.093Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><!-- tocstop --></div><hr><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/dc62badb/">https://blog.zsliang.me/posts/dc62badb/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;!-- tocstop --&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;&lt;br \=&quot;&quot;&gt;&lt;strong&gt;Author:&amp;nbsp;Zachary&lt;/strong&gt;&lt;br \=&quot;&quot;&gt;&lt;strong
      
    
    </summary>
    
      <category term="nil" scheme="https://blog.zsliang.me/categories/nil/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>Design Pattern</title>
    <link href="https://blog.zsliang.me/posts/4dbeaedc/"/>
    <id>https://blog.zsliang.me/posts/4dbeaedc/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-08-18T09:15:44.102Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><!-- tocstop --></div><hr><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/4dbeaedc/">https://blog.zsliang.me/posts/4dbeaedc/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;!-- tocstop --&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;&lt;br \=&quot;&quot;&gt;&lt;strong&gt;Author:&amp;nbsp;Zachary&lt;/strong&gt;&lt;br \=&quot;&quot;&gt;&lt;strong
      
    
    </summary>
    
      <category term="nil" scheme="https://blog.zsliang.me/categories/nil/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>金融学的七个理论</title>
    <link href="https://blog.zsliang.me/posts/dd928e4a/"/>
    <id>https://blog.zsliang.me/posts/dd928e4a/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-08-18T09:15:44.103Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#1-emh-you-xiao-shi-chang-jia-shuo">1. EMH 有效市场假说 </a></li><li><a href="#2-npv-jing-xian-zhi">2. NPV 净现值 </a></li><li><a href="#3-capm-zi-ben-zi-chan-ding-jie-mo-xing">3. CAPM 资本资产定价模型 </a></li><li><a href="#4-jie-zhi-ke-jia-xing-he-jie-zhi-shou-heng-yuan-li">4. 价值可加性和价值守恒原理 </a></li><li><a href="#5-zi-ben-jie-gou-li-lun">5. 资本结构理论 </a></li><li><a href="#6-qi-quan-li-lun">6. 期权理论 </a></li><li><a href="#7-dai-li-li-lun">7. 代理理论 </a></li></ul><!-- tocstop --></div><hr><blockquote><p> 金融学的七个理论 </p></blockquote><h2><span id="1-emh-you-xiao-shi-chang-jia-shuo">1. EMH 有效市场假说 </span><a href="#1-emh-you-xiao-shi-chang-jia-shuo" class="header-anchor">#</a></h2><h2><span id="2-npv-jing-xian-zhi">2. NPV 净现值 </span><a href="#2-npv-jing-xian-zhi" class="header-anchor">#</a></h2><h2><span id="3-capm-zi-ben-zi-chan-ding-jie-mo-xing">3. CAPM 资本资产定价模型 </span><a href="#3-capm-zi-ben-zi-chan-ding-jie-mo-xing" class="header-anchor">#</a></h2><h2><span id="4-jie-zhi-ke-jia-xing-he-jie-zhi-shou-heng-yuan-li">4. 价值可加性和价值守恒原理 </span><a href="#4-jie-zhi-ke-jia-xing-he-jie-zhi-shou-heng-yuan-li" class="header-anchor">#</a></h2><h2><span id="5-zi-ben-jie-gou-li-lun">5. 资本结构理论 </span><a href="#5-zi-ben-jie-gou-li-lun" class="header-anchor">#</a></h2><h2><span id="6-qi-quan-li-lun">6. 期权理论 </span><a href="#6-qi-quan-li-lun" class="header-anchor">#</a></h2><h2><span id="7-dai-li-li-lun">7. 代理理论 </span><a href="#7-dai-li-li-lun" class="header-anchor">#</a></h2><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/dd928e4a/">https://blog.zsliang.me/posts/dd928e4a/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-emh-you-xiao-shi-chang-jia-shuo&quot;&gt;1. EMH 有效市场假说 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-n
      
    
    </summary>
    
      <category term="Finance" scheme="https://blog.zsliang.me/categories/Finance/"/>
    
    
      <category term="Finance" scheme="https://blog.zsliang.me/tags/Finance/"/>
    
      <category term="Thought" scheme="https://blog.zsliang.me/tags/Thought/"/>
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="https://blog.zsliang.me/posts/8069546e/"/>
    <id>https://blog.zsliang.me/posts/8069546e/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-08-18T09:15:44.103Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#data-structure-stack">Data Structure - Stack</a><ul><li><a href="#achieved-an-array-based-stack">Achieved an Array based Stack</a></li></ul></li><li><a href="#call-stack-diao-yong-zhan">Call Stack 调用栈</a></li><li><a href="#ram-area-nei-cun-qu-yu">RAM Area 内存区域</a></li></ul><!-- tocstop --></div><hr><h1><span id="data-structure-stack">Data Structure - Stack</span><a href="#data-structure-stack" class="header-anchor">#</a></h1><h2><span id="achieved-an-array-based-stack">Achieved an Array based Stack</span><a href="#achieved-an-array-based-stack" class="header-anchor">#</a></h2><ul><li>Main methods<ul><li>push</li><li>pop</li><li>top</li><li>isEmpty</li></ul></li></ul><h1><span id="call-stack-diao-yong-zhan">Call Stack 调用栈</span><a href="#call-stack-diao-yong-zhan" class="header-anchor">#</a></h1><blockquote><p>表示函数或子例程像堆积木一样存放，以实现层层调用。<br>程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用，直至完成整个调用栈，返回最后的结果。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line"># Program start</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class()</span><br><span class="line">main()</span><br><span class="line"># Calling Constructor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method()</span><br><span class="line">Class()</span><br><span class="line">main()</span><br><span class="line"># Calling instance method</span><br></pre></td></tr></table></figure><h1><span id="ram-area-nei-cun-qu-yu">RAM Area 内存区域</span><a href="#ram-area-nei-cun-qu-yu" class="header-anchor">#</a></h1><blockquote><p>存放数据的一种内存区域 <br> 一般来说，系统会划分出两种不同的内存空间：<br>Stack 栈 &amp; Heap 堆</p></blockquote><ul><li><p>Diff </p><ul><li>Structure<ul><li>Stack 是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；</li><li>Heap 是没有结构的，数据可以任意存放。</li></ul><ul><li>=&gt; Stack 内变量的分配速度会比 Heap 快，Heap 内分配需要调用 malloc</li><li>=&gt; Stack 的寻址也会比 Heap 快，通过 sp/fp 寄存器间接寻址</li></ul></li><li>Size<ul><li>Init stack 时 size 是确定的，数据超出范围，就会发生溢出 stack overflow</li><li>Heap 的 size 是不确定的，可以按需增加</li></ul><ul><li>=&gt; size(stack) &lt;&lt; size(heap)</li><li>=&gt; 数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在 stack 里面，否则就放在 heap 里面。</li></ul></li><li>Data<ul><li>栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。</li></ul></li><li>Release (操作系统对进程占用的内存空间的两种管理方式)<ul><li>function{…release(stack)}</li><li>Heap 人工释放 malloc()/free()；若程序员不释放，程序结束时由 OS 回收。</li></ul></li><li>Others<ul><li>RAM Address: Stack (h-&gt;l) vs. Heap (l-&gt;h)</li><li>每个线程分配一个 Stack，每个进程分配一个 Heap</li><li>分配效率不同，hardware optim for stack (specific register)</li></ul><ul><li>=&gt; Stack 线程独占，Heap 线程共用</li></ul></li></ul></li><li><p>Example </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">4</span>;</span><br><span class="line">    Class cls = <span class="keyword">new</span> Class();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Main() 结束，会清空 Stack</span></span><br><span class="line"><span class="comment">// 但 Heap 的 cls obj 继续存在，直到 garbage collector 回收这部分内存</span></span><br><span class="line"><span class="comment">// 一般来说，内存泄漏都发生在 heap，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收。</span></span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Stack</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">cls(ref)</span><br><span class="line">val</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Heap</span><br><span class="line">cls obj</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/8069546e/">https://blog.zsliang.me/posts/8069546e/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#data-structure-stack&quot;&gt;Data Structure - Stack&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#achieved-
      
    
    </summary>
    
      <category term="nil" scheme="https://blog.zsliang.me/categories/nil/"/>
    
    
      <category term="nil" scheme="https://blog.zsliang.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>Hash Table</title>
    <link href="https://blog.zsliang.me/posts/491f7c5d/"/>
    <id>https://blog.zsliang.me/posts/491f7c5d/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-05-12T02:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#hash-function">Hash function</a></li><li><a href="#design-a-industrial-level-hash-table">Design a industrial level hash table</a></li><li><a href="#case-java-hashmap">Case: <strong>Java HashMap</strong></a></li><li><a href="#questions">Questions</a></li><li><a href="#reference">Reference</a></li></ul><!-- tocstop --></div><hr><h2><span id="hash-function">Hash function</span><a href="#hash-function" class="header-anchor">#</a></h2><blockquote><p>Hash table utilize the random access feature of array, so it’s kind of extension of array.</p></blockquote><ul><li><p>Design hash function</p><ul><li><code>hash(key)</code> =&gt; <code>index</code> of the table</li><li>Requirements for a hash function<ol><li>The result is always a <strong>non-negative integer</strong></li><li>If <code>key1 == key2</code>, then <code>hash(key1) == hash(key2)</code></li><li>If <code>key1 != key2</code>, then <code>hash(key1) != hash(key2)</code><ul><li>For the 3rd requirement, it’s impossible to achieve</li><li>When <code>key1 != key2</code> and <code>hash(key1) == hash(key2)</code>, we call it hash collision</li></ul></li></ol></li></ul></li><li><p>Solve hash collision problem</p><ul><li>Two ways to solve it<ol><li><strong>Open addressing</strong> 开放寻址法 <ul><li>Main idea: when detect conflict, we find another available place to insert<ul><li>Linear Probing 线性探测 <ul><li><code>hash(key)+0，hash(key)+1，hash(key)+2, ...</code></li></ul></li><li>Quadratic probing 二次探测 <ul><li><code>hash(key)+0，hash(key)+1^2，hash(key)+2^2, ...</code></li></ul></li><li>Double hashing 双重散列 <ul><li><code>hash1(key)，hash2(key)，hash3(key), ...</code> </li></ul></li></ul></li><li>The probability of hash collision will increase with the size increasing, so we use <strong><code>load factor</code></strong> to ensure there are enough space for new elements<ul><li>$load factor = size / capacity$</li></ul></li></ul></li><li><strong>Chaining</strong> 链表法 <ul><li>Each bucket / slot will point to a linked list</li><li>We store the elements with same value of <code>hash(key)</code> in the linked list</li><li>Steps to lookup the value<ul><li>Get bucket by <code>hash(key)</code></li><li>Traverse the linked list <code>node.key == key</code> then <code>return node.val</code> <ul><li>In <code>O(k)</code> time, $k = n / m$, <code>m</code> is the size of the bucket, <code>k</code> is <code>ideal average length of the linked list</code> (distributed evenly)</li></ul></li></ul></li></ul></li></ol></li></ul></li><li><p>Pros &amp; Cons</p><ul><li>Open addressing: Java ThreadLocalMap<ul><li>Pros<ul><li>Easy to serialization</li><li>Improve lookup performance utilizing the CPU Cache since all stored in an array</li></ul></li><li>Cons<ul><li>Complicated to delete elements</li><li>Higher prive for hash collision</li></ul></li><li>When?<ul><li>Small size of data</li><li>Small load factor</li></ul></li></ul></li><li>Chaining: Java LinkedHashMap<ul><li>Pros<ul><li>Higher tolerance for hash collision</li></ul></li><li>Cons<ul><li>Need larger space to store the linkedlist</li><li>Not friendly to CPU Cache which affects the performance</li></ul></li><li>When?<ul><li>Big object and big data size</li><li>More <strong>flexiable optimization strategy</strong><ul><li>Use <strong>red-black tree</strong> / <strong>skiplist</strong> instead of linkedlist<ul><li>Lookup in <code>O(logk)</code> time</li><li>In the extremely case, there only one bucket, still lookup in O(logn) time</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h2><span id="design-a-industrial-level-hash-table">Design a industrial level hash table</span><a href="#design-a-industrial-level-hash-table" class="header-anchor">#</a></h2><blockquote><p>Target</p><ol><li>Avoid sharp drop performance in case of hash collisions</li><li>Resist hash collision attacks</li></ol></blockquote><ul><li><p>Requirements</p><ol><li>Keep it <strong>simple</strong><ul><li>Otherwise it will cost too much computing resource</li></ul></li><li>Result should be <strong>random</strong> and <strong>distributed evenly</strong></li><li>Dynamic expansion<ul><li>Set a <strong>threshold value</strong> for the <strong>load factor</strong></li><li>Once it hits the threshold, expand the table </li><li>Move the elements to the new table <ul><li>In equalization situation, it’s still <code>O(1)</code> for insertion</li><li>But the problem is one-time expansion is time consuming</li><li>Make it inertia, just create space and move later</li></ul></li><li>It’s a <strong>trade-off decision</strong> for when to expand the hash table<ul><li>When the RAM is limited, and not require high performance, $load factore &gt;= 1$ is accectable</li></ul></li></ul></li><li>Dynamic moving<ul><li>Insert one new elem to new table with copying a old one</li><li>Lookup for new table first than the old table</li></ul></li></ol></li><li><p>Summary</p><ul><li>What features an industrial level hash table should have<ol><li>Support quick <code>lookup/insert/delete</code> operations</li><li>Reasonable RAM usage, do not waste too much space </li><li>Stable performance, even in a extreme situation, the performance should be still acceptable</li></ol></li><li>How to design this hash table<ol><li>Design a proper hash function</li><li>Define a proper threshold value for the load factor</li><li>Design a proper dynamic expansion strategy</li><li>Choose a proper method to solve hash collision problem</li></ol></li></ul></li></ul><hr><h2><span id="case-java-hashmap">Case: <strong>Java HashMap</strong></span><a href="#case-java-hashmap" class="header-anchor">#</a></h2><ul><li><p>Design</p><ul><li>Default capacity: <code>16</code></li><li>Max load factor: <code>0.75</code></li><li>Expansion: Double the size</li><li><p>Use chaining method to solve hash collision</p><ul><li>It will <strong>TREEFY</strong> to red-black tree when hits the <code>TREEFY_THRESHOLD = 8</code></li><li><p>Oppositely, it will <strong>UNTREEFY</strong> to linkedlist hits the <code>UNTREEFY_THRESHOLD = 6</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// capitity: capitity of the hash table</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String's hashCode method</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">    <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">            var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.hash = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h2><span id="questions">Questions</span><a href="#questions" class="header-anchor">#</a></h2><ul><li>Q1<ul><li>Q: 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</li><li>Answer<ul><li> 遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O (N)。</li><li> 如果 K 不是很大，可以使用桶排序，时间复杂度 O (N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O (NlogN)。</li></ul></li></ul></li><li>Q2<ul><li>Q: 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</li><li>Answer<ul><li> 以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O (N)。</li></ul></li></ul></li></ul><hr><h2><span id="reference">Reference</span><a href="#reference" class="header-anchor">#</a></h2><ul><li><a href="https://time.geekbang.org/column/intro/126" rel="external nofollow noopener noreferrer" target="_blank"> 数据结构与算法之美 18-19</a></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/491f7c5d/">https://blog.zsliang.me/posts/491f7c5d/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#hash-function&quot;&gt;Hash function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#design-a-industrial-leve
      
    
    </summary>
    
      <category term="Data Structure" scheme="https://blog.zsliang.me/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="https://blog.zsliang.me/tags/Data-Structure/"/>
    
      <category term="HashTable" scheme="https://blog.zsliang.me/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree</title>
    <link href="https://blog.zsliang.me/posts/e0e2589a/"/>
    <id>https://blog.zsliang.me/posts/e0e2589a/</id>
    <published>2019-01-01T05:00:00.000Z</published>
    <updated>2019-05-12T02:00:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><div class="toc"><!-- toc --><ul><li><a href="#definition">Definition</a><ul><li><a href="#traversing-binary-tree">Traversing binary tree</a></li><li><a href="#complexity-analysis">Complexity Analysis</a></li><li><a href="#construct-binary-tree">Construct Binary Tree</a></li></ul></li></ul><!-- tocstop --></div><hr><h2><span id="definition">Definition</span><a href="#definition" class="header-anchor">#</a></h2><ul><li><p>Binary Tree</p><ul><li><p>Each node has only two childs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Classic structure</p><ul><li><strong>BST</strong></li><li><strong>Red-black tree</strong></li><li><strong>Heap</strong></li></ul></li></ul><h3><span id="traversing-binary-tree">Traversing binary tree</span><a href="#traversing-binary-tree" class="header-anchor">#</a></h3><ul><li><p>We can traverse a tree recursively to retrieve all the data in <strong>pre-order</strong>, <strong>in-order</strong> or <strong>post-order</strong></p><ul><li>Pre-order: <code>root-left-right</code></li><li>In-order: <code>left-root-right</code><ul><li>We will get an ordered list after <strong>in-order traversing a BST</strong></li></ul></li><li>Post-order: <code>left-right-root</code></li></ul></li><li><p>Recursive traversal solution</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Preorder Traversal - Recursive Solution*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    result.add(root.val);           <span class="comment">// visit the root</span></span><br><span class="line">    preorder(root.left, result);    <span class="comment">// traverse left subtree</span></span><br><span class="line">    preorder(root.right, result);   <span class="comment">// traverse right subtree</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inorder Traversal - Recursive Solution*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    inorder(root.left, result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    inorder(root.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Postorder Traversal - Recursive Solution*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    postorder(root.left, result);</span><br><span class="line">    postorder(root.right, result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Iterative traversal solution</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Preorder Traversal - Iterative Solution</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        <span class="comment">// root -&gt; left -&gt; right</span></span><br><span class="line">        ret.add(node.val);  </span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);          </span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)  stack.push(node.left);           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inorder</span></span><br><span class="line"><span class="comment">// Left -&gt; Root -&gt; Right (Stack, FILO)</span></span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);          </span><br><span class="line">ret.add(node.val);  </span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>)  stack.push(node.left);</span><br></pre></td></tr></table></figure></li><li><p>DaC perspective</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thought: Divide and Conquer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">dacTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// Divide</span></span><br><span class="line">    ArrayList&lt;Integer&gt; left = dacTraversal(root.left);</span><br><span class="line">    ArrayList&lt;Integer&gt; right = dacTraversal(root.right);</span><br><span class="line">    <span class="comment">// Conquer (adjust the order here)</span></span><br><span class="line">    <span class="comment">// Pre-order: ret.add(root.val); ret.addAll(left);  ret.addAll(right); </span></span><br><span class="line">    <span class="comment">// In-order</span></span><br><span class="line">    ret.addAll(left);  ret.add(root.val); ret.addAll(right); </span><br><span class="line">    <span class="comment">// Post-order: ret.addAll(left);  ret.addAll(right); ret.add(root.val); </span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="complexity-analysis">Complexity Analysis</span><a href="#complexity-analysis" class="header-anchor">#</a></h3><ul><li><p>Complexity</p><ul><li>T: <code>O(n)</code><ul><li>Because we visit each node exactly once.</li></ul></li><li>S: <code>O(n)</code> / <code>O(1)</code><ul><li>Taking system stack into consideration</li><li>Worst case, $level = size$</li></ul></li></ul></li><li><p>To be cautious</p><ul><li>When the depth of tree is too large, we might suffer from stack overflow problem, and the depth of the tree might be N in the worst case.<ul><li>That’s one of the main reasons why we want to solve this problem iteratively sometimes. </li></ul></li><li>And the complexity might be different due to a different implementation. </li></ul></li></ul><hr><h3><span id="construct-binary-tree">Construct Binary Tree</span><a href="#construct-binary-tree" class="header-anchor">#</a></h3><ul><li><p>From Inorder and Preorder Traversal</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder: [root, [left-subtree], [right-subtree]]</span><br><span class="line">inorder:  [[left-subtree], root, [right-subtree]]</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> iS, <span class="keyword">int</span> iE, <span class="keyword">int</span> pS)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iS &gt; iE)  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(iS == iE) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[iS]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This part can be optim by using HashMap</span></span><br><span class="line">    <span class="keyword">int</span> iRoot = iS;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = iS; i &lt;= iE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == preorder[pS]) &#123;</span><br><span class="line">            iRoot = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(inorder[iRoot]);</span><br><span class="line">    root.left = buildTree(preorder, inorder, iS, iRoot - <span class="number">1</span>, pS + <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, iRoot + <span class="number">1</span>, iE, pS + (iRoot - iS) + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>From Inorder and Postorder Traversal</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postorder: [[left-subtree], [right-subtree], root]</span><br><span class="line">inorder:   [[left-subtree], root, [right-subtree]]</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildTree(inorder, postorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> iS, <span class="keyword">int</span> iE, <span class="keyword">int</span> pE)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iS &gt; iE)  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(iS == iE) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[iS]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This part can be optim by using HashMap</span></span><br><span class="line">    <span class="keyword">int</span> iRoot = iS;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = iS; i &lt;= iE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == postorder[pE]) &#123;</span><br><span class="line">            iRoot = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(inorder[iRoot]);</span><br><span class="line">    root.left = buildTree(inorder, postorder, iS, iRoot - <span class="number">1</span>, pE - (iE - iRoot) - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(inorder, postorder, iRoot + <span class="number">1</span>, iE, pE - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br \=""><strong>Author:&nbsp;Zachary</strong><br \=""><strong>Post link:&nbsp;</strong> <a href="https://blog.zsliang.me/posts/e0e2589a/">https://blog.zsliang.me/posts/e0e2589a/</a> <br \=""><strong>Copyright:&nbsp;</strong>All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><b>CC BY-NC-SA 4.0</b></a> unless stating additionally.<br \=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#definition&quot;&gt;Definition&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#traversing-binary-tree&quot;&gt;Travers
      
    
    </summary>
    
      <category term="Data Structure" scheme="https://blog.zsliang.me/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="https://blog.zsliang.me/tags/Data-Structure/"/>
    
      <category term="Tree" scheme="https://blog.zsliang.me/tags/Tree/"/>
    
  </entry>
  
</feed>
